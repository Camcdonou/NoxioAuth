"use strict";
/* global Asset */

/* This JS file was generated by NoxioAssetConverter */
Asset.prototype.shader = {};

/* Source File: particlemodelRBg */
Asset.prototype.shader.particlemodelRB = {
  name: "particlemodelRB",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "vec3", name: "angle"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "int", name: "frame"},
    {type: "vec2", name: "alpha"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform vec3 angle;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  vec3 hacky = rotateX(rotateZ(rotateY(position, angle.x), angle.y), -angle.z);\n\n  vec4 cPos = vec4((hacky*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform int frame;\nuniform vec2 alpha;\n\nvarying vec3 vUV;\n\nvec3 RGBToHSL(vec3 color)\n{\nvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\nfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\nfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\nfloat delta = fmax - fmin; //Delta RGB value\n\nhsl.z = (fmax + fmin) / 2.0; // Luminance\n\nif (delta == 0.0)	//This is a gray, no chroma...\n{\nhsl.x = 0.0;	// Hue\nhsl.y = 0.0;	// Saturation\n}\nelse //Chromatic data...\n{\nif (hsl.z < 0.5)\nhsl.y = delta / (fmax + fmin); // Saturation\nelse\nhsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\nfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\nif (color.r == fmax )\nhsl.x = deltaB - deltaG; // Hue\nelse if (color.g == fmax)\nhsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\nelse if (color.b == fmax)\nhsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\nif (hsl.x < 0.0)\nhsl.x += 1.0; // Hue\nelse if (hsl.x > 1.0)\nhsl.x -= 1.0; // Hue\n}\n\nreturn hsl;\n\n}\n\nfloat HueToRGB(float f1, float f2, float hue)\n{\nif (hue < 0.0)\nhue += 1.0;\nelse if (hue > 1.0)\nhue -= 1.0;\nfloat res;\nif ((6.0 * hue) < 1.0)\nres = f1 + (f2 - f1) * 6.0 * hue;\nelse if ((2.0 * hue) < 1.0)\nres = f2;\nelse if ((3.0 * hue) < 2.0)\nres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\nelse\nres = f1;\nreturn res;\n}\n\nvec3 HSLToRGB(vec3 hsl)\n{\nvec3 rgb;\n\nif (hsl.y == 0.0)\nrgb = vec3(hsl.z); // Luminance\nelse\n{\nfloat f2;\n\nif (hsl.z < 0.5)\nf2 = hsl.z * (1.0 + hsl.y);\nelse\nf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\nfloat f1 = 2.0 * hsl.z - f2;\n\nrgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\nrgb.g = HueToRGB(f1, f2, hsl.x);\nrgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n}\n\nreturn rgb;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n  vec3 hsly = RGBToHSL(color);\n  hsly.x = mod(hsly.x+hueAdjust, 1.);\n  return HSLToRGB(hsly);\n}\n\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st);\n  vec3 rba = texture2D(texture1, vUV.st).rgb;\n  vec3 rbb = texture2D(texture2, vUV.st).rgb;\n  vec4 colored = mix(vec4(rba, alpha.x), vec4(rbb, alpha.y), tex.r);\n  gl_FragColor = vec4(hueShift(colored.rgb, float(frame) * 0.073), colored.a * tex.a);\n}\n",
};

/* Source File: playershinyg */
Asset.prototype.shader.playershiny = {
  name: "playershiny",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture5"},
    {type: "samplerCube", name: "cube"},
    {type: "vec3", name: "color"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture2;      // Shiny Color\nuniform sampler2D texture5;      // Shadowmap Depth\nuniform samplerCube cube;\n\n/* General */\nuniform vec3 color;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec3  texDiffuse = texture2D(texture0, vUV.st).rgb;\n  vec3  texNormal  = texture2D(texture1, vUV.st).rgb;\n  vec3  texShine  = texture2D(texture2, vUV.st).rgb;\n  float texSpec    = texture2D(texture0, vUV.st).a;\n\n  float broit = (texDiffuse.r+texDiffuse.g+texDiffuse.b)/3.;\n  vec3 colorize = broit > .5              ?\n  (mix(color, vec3(1.), (broit-.5)*2.)) :\n  (mix(vec3(0.), color, (broit)*2.))     ;\n  vec3 texColor=colorize;\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Cubemap */\n  vec3 cRef  = reflect(normalize(vPos-(-eyeCenter)), normal);\n  vec3 texCube = textureCube(cube, cRef).rgb;\n  \n  /* Mix Color */\n  vec3 qBroit = vec3((texCube.r + texCube.g + texCube.b)/3.);\n  vec3 recolor = broit > 0.725 ? mix(texShine*qBroit, vec3(1.), 0.15) : texColor;\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n\n  /* Finalize */\n  gl_FragColor = vec4(recolor*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: orbg */
Asset.prototype.shader.orb = {
  name: "orb",
  attributes: [
    {type: "vec3", name: "position"},
  ],
  uniforms: [
    {type: "int", name: "frame"},
    {type: "vec2", name: "cameraCenter"},
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\nprecision mediump int;\n\nattribute vec3 position;\n\nuniform int frame;\nuniform vec2 cameraCenter;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float scale;\n\nvarying vec2 sCenter;\nvarying vec2 sPos;\nvarying vec2 vUV;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  float rescale = 1.05+(sin(float(frame)*.062)*.02);\n\n  vec4 cPos = vec4((position*(scale*rescale))+transform, 1.);\n\n  mat4 Smatrix = mat4(2.747476100921631, 0, 0, 0, 0, 2.747476100921631, 0, 0, 0, 0, -1.0317460298538208, -1, 0, 0, -2.0317461490631104, 0);\n\n  vec4 nani = Pmatrix*Vmatrix*Mmatrix*vec4(transform, 1.);\n\n  sCenter = (Smatrix*Vmatrix*Mmatrix*vec4(transform, 1.)).xy;\n  sPos = (Smatrix*Vmatrix*Mmatrix*vec4(position+transform, 1.)).xy;\n\n  vUV=(Smatrix*Vmatrix*Mmatrix*vec4(position, 1.)).xy-sCenter;\n\n  vec4 vored = Pmatrix*Vmatrix*Mmatrix*cPos;\n  vored.z = nani.z; vored.w = nani.w;\n  gl_Position = vored;\n}\n\n/* @TODO: OPTIMIZE, lots of duplicate/uneeded math */\n",
  fragment: "precision mediump float;\nprecision mediump int;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Multi Diff\n\nuniform int frame;\n\n/* General */\nvarying vec2 sCenter;\nvarying vec2 sPos;\nvarying vec2 vUV;\n\nvoid main(void) {\n  /* Texture Samples */\n  float ff = float(frame);\n  float multiR     = texture2D(texture0, (vUV+vec2(ff*0.00113, ff*0.00097))).r;\n  float multiG     = texture2D(texture0, (vUV+vec2(-ff*0.00013, ff*0.00267))).g;\n  float multiB     = texture2D(texture0, (vUV+vec2(ff*0.00211, -ff*0.00143))).b;\n  float multiA     = texture2D(texture0, (vUV+vec2(-ff*0.00171, -ff*0.00123))*-1.).r; /* Yeah I know... remind me to add an A channel to it */\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n\n  vec4 colorA = vec4(0.0, 0.0, 0.0, 1.0);\n  vec4 colorB = vec4(1.0, 1.0, 1.0, 1.0 + min(1., max(0.0001, plasGlow)));\n  vec4 colorC = vec4(1.0, 1.0, 1.0, 0.0);\n\n  float scalarA;\n  float scalarB;\n  float dist = distance(sCenter, sPos);\n  if(dist < 0.7) {\n    scalarA = 0.;\n    scalarB = 0.;\n  }\n  else {\n    if(dist < .75) {\n      scalarA = (dist-.7)/.05;\n      scalarB = 0.;\n    }\n    else {\n      scalarA = 1.;\n      scalarB = pow((dist-.75)/.25, .25);\n    }\n  }\n  /* Finalize */\n  gl_FragColor = mix(colorA, mix(colorB, colorC, scalarB), scalarA);\n}\n",
};

/* Source File: particleRBg */
Asset.prototype.shader.particleRB = {
  name: "particleRB",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "int", name: "frame"},
    {type: "vec2", name: "alpha"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((vec4(rotate(position, rotation)*scale, 1.0)*Dmatrix).xyz+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform int frame;\nuniform vec2 alpha;\n\nvarying vec3 vUV;\n\nvec3 RGBToHSL(vec3 color)\n{\nvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\nfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\nfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\nfloat delta = fmax - fmin; //Delta RGB value\n\nhsl.z = (fmax + fmin) / 2.0; // Luminance\n\nif (delta == 0.0)	//This is a gray, no chroma...\n{\nhsl.x = 0.0;	// Hue\nhsl.y = 0.0;	// Saturation\n}\nelse //Chromatic data...\n{\nif (hsl.z < 0.5)\nhsl.y = delta / (fmax + fmin); // Saturation\nelse\nhsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\nfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\nif (color.r == fmax )\nhsl.x = deltaB - deltaG; // Hue\nelse if (color.g == fmax)\nhsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\nelse if (color.b == fmax)\nhsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\nif (hsl.x < 0.0)\nhsl.x += 1.0; // Hue\nelse if (hsl.x > 1.0)\nhsl.x -= 1.0; // Hue\n}\n\nreturn hsl;\n\n}\n\nfloat HueToRGB(float f1, float f2, float hue)\n{\nif (hue < 0.0)\nhue += 1.0;\nelse if (hue > 1.0)\nhue -= 1.0;\nfloat res;\nif ((6.0 * hue) < 1.0)\nres = f1 + (f2 - f1) * 6.0 * hue;\nelse if ((2.0 * hue) < 1.0)\nres = f2;\nelse if ((3.0 * hue) < 2.0)\nres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\nelse\nres = f1;\nreturn res;\n}\n\nvec3 HSLToRGB(vec3 hsl)\n{\nvec3 rgb;\n\nif (hsl.y == 0.0)\nrgb = vec3(hsl.z); // Luminance\nelse\n{\nfloat f2;\n\nif (hsl.z < 0.5)\nf2 = hsl.z * (1.0 + hsl.y);\nelse\nf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\nfloat f1 = 2.0 * hsl.z - f2;\n\nrgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\nrgb.g = HueToRGB(f1, f2, hsl.x);\nrgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n}\n\nreturn rgb;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n  vec3 hsly = RGBToHSL(color);\n  hsly.x = mod(hsly.x+hueAdjust, 1.);\n  return HSLToRGB(hsly);\n}\n\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st);\n  vec3 rba = texture2D(texture1, vUV.st).rgb;\n  vec3 rbb = texture2D(texture2, vUV.st).rgb;\n  vec4 colored = mix(vec4(rba, alpha.x), vec4(rbb, alpha.y), tex.r);\n  gl_FragColor = vec4(hueShift(colored.rgb, float(frame) * 0.073), colored.a * tex.a);\n}\n",
};

/* Source File: zoneg */
Asset.prototype.shader.zone = {
  name: "zone",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "int", name: "frame"},
    {type: "vec3", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 scale; /* Change to size */\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 cPos = vec4((position*scale)+transform, 1.);\n  vUV=texcoord*vec3(scale.x, -1., 1.);\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\n/* Texture Samples */\nuniform sampler2D texture0;\nuniform sampler2D texture1;\n\n/* General */\nuniform int  frame;\nuniform vec3 color;\nvarying vec3 vUV;\n\nvoid main(void) {\n\n  float ff = float(frame);\n  vec4 diffuse = texture2D(texture0, vUV.st+vec2(ff*0.0067, 0.0));\n  vec4 gradient = texture2D(texture1, vUV.st);\n\n  gl_FragColor = vec4(gradient.rgb+(diffuse.rgb*.25), gradient.a)*vec4(color, 1.);\n}\n",
};

/* Source File: finaling */
Asset.prototype.shader.finalin = {
  name: "finalin",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nvarying vec2 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform int frame;\n\nvarying vec2 vUV;\n\nvoid main(void) {\n  float ftime = float(frame);  // No implicit casting in glsl.\n\n  float texMask = texture2D(texture2, vUV).g;\n  vec4  texColor = texture2D(texture1, vUV + vec2(ftime*.0001, 0.));\n\n  float texMaskA = texture2D(texture0, (vUV * vec2(6., 1.)) + vec2(ftime*.0009, 0.)).r;\n  float texMaskB = texture2D(texture0, (vUV * vec2(5., 1.)) + vec2(-ftime*.0004, 0.)).g;\n  float texMaskC = texture2D(texture0, (vUV * vec2(5., 1.)) + vec2(ftime*.0003, 0.)).b;\n  float texMaskD = texture2D(texture0, (vUV * vec2(6., 1.)) + vec2(-ftime*.0007, 0.)).a;\n\n  float noise = min(1., max(0., (texMaskA + texMaskB + texMaskC + texMaskD)-1.5));\n\n  vec4 neb = vec4(texColor.rgb, texColor.a * texMask * noise);\n\n  gl_FragColor = neb;\n}\n",
};

/* Source File: ting */
Asset.prototype.shader.tin = {
  name: "tin",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture3"},
    {type: "sampler2D", name: "texture5"},
    {type: "int", name: "frame"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n  vec3 up = vec3(0.,0.,1.);\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  wUV = rotateX(rotateZ(rotateY(vPos, axAng.x), axAng.y), -axAng.z).st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture2;      // Edge\nuniform sampler2D texture3;      // Multi\nuniform sampler2D texture5;      // Shadowmap Depth Texture\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nvec3 plasma(sampler2D texColor, sampler2D texDiff, vec2 uv, float scale) {\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  float multiR     = texture2D(texDiff, (uv+vec2(ff*0.00113, ff*0.00097))*scale).r;\n  float multiG     = texture2D(texDiff, (uv+vec2(-ff*0.00013, ff*0.00267))*scale).g;\n  float multiB     = texture2D(texDiff, (uv+vec2(ff*0.00211, -ff*0.00143))*scale).b;\n  float multiA     = texture2D(texDiff, (uv+vec2(-ff*0.00171, -ff*0.00123)*scale)*-1.).r; /* @TODO: Yeah I know... remind me to add an A channel to it */\n  vec3  texGlowA   = texture2D(texColor, gt).rgb;\n  vec3  texGlowB   = texture2D(texColor, gt+vec2(.5, 0.)).rgb;\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n  \n  return mix(texGlowA, (texGlowB+vec3(.15))*((sin(ff*.0127)*.25)+1.5), min(max(0.0001, plasGlow), 1.));\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  vec3  texDiffuse = texture2D(texture0, wUV*.95).rgb;\n  vec3  texNormal  = texture2D(texture1, wUV*.85).rgb;\n  float texSpec    = texture2D(texture0, wUV*.75).a;  \n  vec3 glow = plasma(texture2, texture3, wUV, 2.);\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  if(vUV.s >= 0.) {\n    gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n  }\n  else {\n    gl_FragColor = vec4(glow, 1.);\n  }\n}\n",
};

/* Source File: effectg */
Asset.prototype.shader.effect = {
  name: "effect",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((rotate(position, rotation)*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nuniform vec4 color;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st)*color;\n  gl_FragColor = tex;\n}\n",
};

/* Source File: post_fxaag */
Asset.prototype.shader.post_fxaa = {
  name: "post_fxaa",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec3", name: "textureProp"},
    {type: "vec2", name: "resolution"},
    {type: "float", name: "upscale"},
    {type: "sampler2D", name: "texture6"},
    {type: "sampler2D", name: "texture7"},
    {type: "vec3", name: "textureProp"},
    {type: "vec2", name: "resolution"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec3 textureProp; //Proportions relative to FBO texture size\nuniform vec2 resolution;\nuniform float upscale;\n\nvarying vec2 vUV;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvoid texcoords(vec2 fragCoord, vec2 resolution,\n			out vec2 v_rgbNW, out vec2 v_rgbNE,\n			out vec2 v_rgbSW, out vec2 v_rgbSE,\n			out vec2 v_rgbM) {\n	vec2 inverseVP = 1.0 / resolution.xy;\n	v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;\n	v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;\n	v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;\n	v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;\n	v_rgbM = vec2(fragCoord * inverseVP);\n}\n\nvoid main(void) {\n  vUV = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp.st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUV.t -= textureProp.z;\n  vUV = vUV*upscale;\n\n  texcoords(vUV*resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n\n  gl_Position = Pmatrix*Vmatrix*vec4(position,1.0);\n}\n",
  fragment: "precision mediump float;\n\n/**\nBasic FXAA implementation based on the code on geeks3d.com with the\nmodification that the texture2DLod stuff was removed since it's\nunsupported by WebGL.\n--\nFrom:\nhttps://github.com/mitsuhiko/webgl-meincraft\nCopyright (c) 2011 by Armin Ronacher.\nSome rights reserved.\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are\nmet:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above\n      copyright notice, this list of conditions and the following\n      disclaimer in the documentation and/or other materials provided\n      with the distribution.\n    * The names of the contributors may not be used to endorse or\n      promote products derived from this software without specific\n      prior written permission.\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n'AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\nLIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\nA PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\nOWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\nSPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\nTHEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef FXAA_REDUCE_MIN\n    #define FXAA_REDUCE_MIN   (1.0/ 128.0)\n#endif\n#ifndef FXAA_REDUCE_MUL\n    #define FXAA_REDUCE_MUL   (1.0 / 8.0)\n#endif\n#ifndef FXAA_SPAN_MAX\n    #define FXAA_SPAN_MAX     8.0\n#endif\n\n//optimized version for mobile, where dependent \n//texture reads can be a bottleneck\nvec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 resolution,\n            vec2 v_rgbNW, vec2 v_rgbNE, \n            vec2 v_rgbSW, vec2 v_rgbSE, \n            vec2 v_rgbM) {\n    vec4 color;\n    mediump vec2 inverseVP = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;\n    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;\n    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;\n    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;\n    vec4 texColor = texture2D(tex, v_rgbM);\n    vec3 rgbM  = texColor.xyz;\n    vec3 luma = vec3(0.299, 0.587, 0.114);\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n    \n    mediump vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *\n                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    \n    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n              dir * rcpDirMin)) * inverseVP;\n    \n    vec3 rgbA = 0.5 * (\n        texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);\n    vec3 rgbB = rgbA * 0.5 + 0.25 * (\n        texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +\n        texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);\n\n    float lumaB = dot(rgbB, luma);\n    if ((lumaB < lumaMin) || (lumaB > lumaMax))\n        color = vec4(rgbA, texColor.a);\n    else\n        color = vec4(rgbB, texColor.a);\n    return color;\n}\n\nuniform sampler2D texture6;\nuniform sampler2D texture7;\n\nuniform vec3 textureProp; //Proportions relative to FBO texture size\nuniform vec2 resolution;\n\nvarying vec2 vUV;\n\nvarying vec2 v_rgbNW;\nvarying vec2 v_rgbNE;\nvarying vec2 v_rgbSW;\nvarying vec2 v_rgbSE;\nvarying vec2 v_rgbM;\n\nvoid main(void) {\n  vec4 world = fxaa(texture6, vUV*resolution, resolution, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);\n  vec4 ui = texture2D(texture7, vUV);\n  vec4 color = ((1.0 - ui.a) * world) + (ui * ui.a);\n  gl_FragColor = vec4(color.rgb, 1.0);\n}\n",
};

/* Source File: post_msaag */
Asset.prototype.shader.post_msaa = {
  name: "post_msaa",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3[]", name: "textureProp"},
    {type: "vec2", name: "resolution"},
    {type: "float[]", name: "upscale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture6"},
    {type: "sampler2D", name: "texture7"},
    {type: "sampler2D", name: "texture8"},
    {type: "sampler2D", name: "texture9"},
    {type: "sampler2D", name: "texture10"},
    {type: "sampler2D", name: "texture11"},
    {type: "float", name: "bloomTextureAspect"},
    {type: "float", name: "bloomTextureScale"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec3 transform;\n\nuniform vec3 textureProp[4]; //Proportions relative to FBO texture size\nuniform vec2 resolution;\nuniform float upscale[4];\n\nvarying vec2 vUVworld[3];\nvarying vec2 vUVui;\nvarying vec2 vUVsky;\n\nvoid main(void) {\n  vUVworld[0] = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[0].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVworld[0] = vUVworld[0]*upscale[0];\n  vUVworld[0].t -= textureProp[0].z;\n\n  vec2 pixOffset = 0.5/(resolution/upscale[0]);\n  vUVworld[1] = vUVworld[0] + vec2(pixOffset.x, 0.0);\n  vUVworld[2] = vUVworld[0] + vec2(0.0, pixOffset.y);\n\n  vUVui = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[1].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVui = vUVui*upscale[1];\n  vUVui.t -= textureProp[1].z;\n  \n  vUVsky = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[2].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVsky = vUVsky*upscale[2];\n  vUVsky.t -= textureProp[2].z;\n\n  gl_Position = Pmatrix*Vmatrix*vec4(position,1.0);\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture6;   // Game World\nuniform sampler2D texture7;   // UI\nuniform sampler2D texture8;   // Sky\nuniform sampler2D texture9;   // Game World Bloom\nuniform sampler2D texture10;  // Game World Depth\nuniform sampler2D texture11;  // Game World Bloom Depth\n\nuniform float bloomTextureAspect; // To adjust the vertical/horizontal radius of bloom blurring\nuniform float bloomTextureScale;  // To adjust for the amount texture space actually used by the fbo\n\nvarying vec2 vUVworld[3];\nvarying vec2 vUVui;\nvarying vec2 vUVsky;\n\nvoid main(void) {\n  vec4 worldSampA = texture2D(texture6, vUVworld[0]);\n  vec4 worldSampB = texture2D(texture6, vUVworld[1]);\n  vec4 worldSampC = texture2D(texture6, vUVworld[2]);\n\n  vec4 world = (worldSampA+worldSampB+worldSampC)/3.; /* @TODO: Great Value MSAA / Should sample pixels in area based on fbo//actual resolution */\n  vec4 ui = texture2D(texture7, vUVui);\n  vec4 sky = texture2D(texture8, vUVsky);\n\n  // Sky + World\n  vec3 color = vec3((world.a*world.rgb)+((1.-world.a)*sky.rgb));\n\n  // + UI\n  color = ((1. - ui.a) * color) + (ui.rgb * ui.a);\n  \n  gl_FragColor = vec4(color, 1.);\n}\n",
};

/* Source File: simpletransg */
Asset.prototype.shader.simpletrans = {
  name: "simpletrans",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec2", name: "transform"},
    {type: "vec2", name: "size"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec2 transform;\nuniform vec2 size;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 cPos = vec4((position*vec3(size,1.0))+vec3(transform, -0.5), 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform vec4 color;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  gl_FragColor = texture2D(texture0, vUV.st) * color;\n}\n",
};

/* Source File: finalcometg */
Asset.prototype.shader.finalcomet = {
  name: "finalcomet",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nvarying vec2 vUV;\nvarying float rainbowOffset;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n  rainbowOffset = offset.x;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\n\nuniform int frame;\n\nvarying vec2 vUV;\nvarying float rainbowOffset;\n\nvoid main(void) {\n  float ftime = float(frame);  // No implicit casting in glsl.\n\n  float texMask = texture2D(texture0, vUV).r;\n  float texAlpha = texture2D(texture0, vUV).a;\n  vec3  texColor = texture2D(texture1, (vUV * vec2(.33, 1.))+vec2(rainbowOffset, 0.)+(vec2(-.015*ftime, 0.))).rgb;\n\n  vec4 comet = vec4(texColor, pow(texMask, 2.)*texAlpha);\n\n  gl_FragColor = comet;\n}\n",
};

/* Source File: particlespriteRBg */
Asset.prototype.shader.particlespriteRB = {
  name: "particlespriteRB",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "int", name: "frame"},
    {type: "int", name: "totalSprites"},
    {type: "int", name: "usedSprites"},
    {type: "int", name: "rbFrame"},
    {type: "vec2", name: "alpha"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((vec4(rotate(position, rotation)*scale, 1.0)*Dmatrix).xyz+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform int frame;\nuniform int totalSprites;\nuniform int usedSprites;\n\nuniform int rbFrame; /* oof */\nuniform vec2 alpha;\n\nvarying vec3 vUV;\n\nvec3 RGBToHSL(vec3 color)\n{\nvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\nfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\nfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\nfloat delta = fmax - fmin; //Delta RGB value\n\nhsl.z = (fmax + fmin) / 2.0; // Luminance\n\nif (delta == 0.0)	//This is a gray, no chroma...\n{\nhsl.x = 0.0;	// Hue\nhsl.y = 0.0;	// Saturation\n}\nelse //Chromatic data...\n{\nif (hsl.z < 0.5)\nhsl.y = delta / (fmax + fmin); // Saturation\nelse\nhsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\nfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\nif (color.r == fmax )\nhsl.x = deltaB - deltaG; // Hue\nelse if (color.g == fmax)\nhsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\nelse if (color.b == fmax)\nhsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\nif (hsl.x < 0.0)\nhsl.x += 1.0; // Hue\nelse if (hsl.x > 1.0)\nhsl.x -= 1.0; // Hue\n}\n\nreturn hsl;\n\n}\n\nfloat HueToRGB(float f1, float f2, float hue)\n{\nif (hue < 0.0)\nhue += 1.0;\nelse if (hue > 1.0)\nhue -= 1.0;\nfloat res;\nif ((6.0 * hue) < 1.0)\nres = f1 + (f2 - f1) * 6.0 * hue;\nelse if ((2.0 * hue) < 1.0)\nres = f2;\nelse if ((3.0 * hue) < 2.0)\nres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\nelse\nres = f1;\nreturn res;\n}\n\nvec3 HSLToRGB(vec3 hsl)\n{\nvec3 rgb;\n\nif (hsl.y == 0.0)\nrgb = vec3(hsl.z); // Luminance\nelse\n{\nfloat f2;\n\nif (hsl.z < 0.5)\nf2 = hsl.z * (1.0 + hsl.y);\nelse\nf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\nfloat f1 = 2.0 * hsl.z - f2;\n\nrgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\nrgb.g = HueToRGB(f1, f2, hsl.x);\nrgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n}\n\nreturn rgb;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n  vec3 hsly = RGBToHSL(color);\n  hsly.x = mod(hsly.x+hueAdjust, 1.);\n  return HSLToRGB(hsly);\n}\n\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vec2(vUV.x, (vUV.y/float(totalSprites)) + ((1./float(totalSprites)) * mod(float(frame), float(usedSprites)))));\n  vec3 rba = texture2D(texture1, vUV.st).rgb;\n  vec3 rbb = texture2D(texture2, vUV.st).rgb;\n  vec4 colored = mix(vec4(rba, alpha.x), vec4(rbb, alpha.y), tex.r);\n  gl_FragColor = vec4(hueShift(colored.rgb, float(rbFrame) * 0.073), colored.a * tex.a);\n}\n",
};

/* Source File: copper_wallg */
Asset.prototype.shader.copper_wall = {
  name: "copper_wall",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture3"},
    {type: "sampler2D", name: "texture5"},
    {type: "int", name: "frame"},
    {type: "float", name: "scale"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n  vec3 up = vec3(0.,0.,1.);\n  vec3 axis = cross(up, normal);\n  float angle = acos(dot(up, normal));\n  vec3 axAng = axisAngle(axis, angle);\n  wUV = rotateX(rotateZ(rotateY(((position+vec3(-1.,-1.,0.))*scale)+transform, axAng.x), axAng.y), -axAng.z).st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture2;      // Edge\nuniform sampler2D texture3;      // Multi\nuniform sampler2D texture5;      // Shadowmap Depth Texture\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\nuniform float scale;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nvec3 plasma(sampler2D texColor, sampler2D texDiff, vec2 uv, float scale) {\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  float multiR     = texture2D(texDiff, (uv+vec2(ff*0.00113, ff*0.00097))*scale).r;\n  float multiG     = texture2D(texDiff, (uv+vec2(-ff*0.00013, ff*0.00267))*scale).g;\n  float multiB     = texture2D(texDiff, (uv+vec2(ff*0.00211, -ff*0.00143))*scale).b;\n  float multiA     = texture2D(texDiff, (uv+vec2(-ff*0.00171, -ff*0.00123)*scale)*-1.).r; /* @TODO: Yeah I know... remind me to add an A channel to it */\n  vec3  texGlowA   = texture2D(texColor, gt).rgb;\n  vec3  texGlowB   = texture2D(texColor, gt+vec2(.5, 0.)).rgb;\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n  \n  return mix(texGlowA, (texGlowB+vec3(.15))*((sin(ff*.0127)*.25)+1.5), min(max(0.0001, plasGlow), 1.));\n}\n\n\nvoid main(void) {\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec3  texDiffuse = texture2D(texture0, wUV*.95).rgb;\n  vec3  texNormal  = texture2D(texture1, wUV*(2./scale)).rgb;\n  float texSpec    = texture2D(texture0, wUV*.95).a;\n  \n  vec3 glow = plasma(texture2, texture3, wUV, 2.);\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  if(vUV.s >= 0.) {\n    gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n  }\n  else {\n    gl_FragColor = vec4(glow, 1.);\n  }\n}\n",
};

/* Source File: effect_slashg */
Asset.prototype.shader.effect_slash = {
  name: "effect_slash",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "vec4", name: "color"},
    {type: "vec4", name: "tone"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((rotate(position, rotation)*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\n\nuniform vec4 color;\nuniform vec4 tone;\nuniform int frame;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec2 uv = (vUV.st*vec2(0.5,1.0))+vec2(1.0, 0.0)-vec2(float(frame)*0.1725, 1.0);\n  if(uv.x > 1.0 || uv.x < 0.0) { discard; }\n  vec4 gradTex = texture2D(texture1, uv);\n  vec4 maskTex = texture2D(texture0, vUV.st);\n  vec4 colored = mix(tone, color, maskTex.r);\n  colored.a *= maskTex.a*gradTex.a;\n  gl_FragColor = colored;\n}\n",
};

/* Source File: glowg */
Asset.prototype.shader.glow = {
  name: "glow",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vUV;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((rotateZ(position, rotation)*scale)+transform, 1.0);\n  vUV=texcoord;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse\n\n/* General */\nvarying vec3 vUV;\n\nvoid main(void) {\n  /* Texture Samples */\n  vec3  texDiffuse = texture2D(texture0, vUV.st).rgb;\n\n  /* Finalize */\n  gl_FragColor = vec4(texDiffuse, 1.);\n}\n",
};

/* Source File: decal_glow_nonegg */
Asset.prototype.shader.decal_glow_noneg = {
  name: "decal_glow_noneg",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec3", name: "dPos"},
    {type: "vec3", name: "dNormal"},
    {type: "float", name: "dSize"},
    {type: "float", name: "dAngle"},
    {type: "vec4", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.0);\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nvarying vec3 vPos;\n\nuniform vec3 dPos;\nuniform vec3 dNormal;\nuniform float dSize;\nuniform float dAngle;\n\nuniform vec4 color;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  vec3 rPos = dPos-vPos;\n  rPos = rotateZ(rPos, -dAngle);\n  vec3 dUVW = (rPos+vec3(0.5/dSize))*dSize;\n\n  vec4 tex=vec4(texture2D(texture0, dUVW.st));\n\n  if(dUVW.s > 0.0 && dUVW.s < 1.0 && dUVW.t > 0.0 && dUVW.t < 1.0 && dUVW.p > 0.425 && dUVW.p < 0.55) { gl_FragColor = tex*color; }\n  else { discard; }\n}\n",
};

/* Source File: goldlavag */
Asset.prototype.shader.goldlava = {
  name: "goldlava",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture5"},
    {type: "int", name: "frame"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture5;      // Shadowmap Depth\nconst float TEXEL_SIZE_X = 16.;\nconst float TEXEL_SIZE_Y = 512.;\nconst float ASPECT = TEXEL_SIZE_X/TEXEL_SIZE_Y;\nconst float TEXEL_OFFSET_X = (1./TEXEL_SIZE_X)*.5;\nconst float TEXEL_OFFSET_Y = (1./TEXEL_SIZE_Y)*.5;\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.1;\nconst vec3   aLightColor = vec3(0.93, 0.93, 0.89);\nconst vec3   aShadowColor = vec3(0.68, 0.69, 0.77);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nfloat trunc(float f) {\n  return f >= 0. ? floor(f) : ceil(f);\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec2  coordTexel = vec2((trunc(vUV.x*TEXEL_SIZE_X)/TEXEL_SIZE_X)+TEXEL_OFFSET_X, ((trunc(ASPECT*vUV.y*TEXEL_SIZE_Y)/TEXEL_SIZE_Y)+TEXEL_OFFSET_Y)+((abs(mod(float(frame/4), 38.) - 19.))*(16./TEXEL_SIZE_Y)));\n  vec3  texDiffuse = texture2D(texture0, coordTexel).rgb;\n  float texSpec    = texture2D(texture0, coordTexel).a;\n\n  /* Normal */\n  vec3 normal = vNormal;\n\n  /* Specular */\n  /*float specular = specularMap(texSpec, normal);*/\n  float specular = .25;\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: goldwaterg */
Asset.prototype.shader.goldwater = {
  name: "goldwater",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture5"},
    {type: "int", name: "frame"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture5;      // Shadowmap Depth\nconst float TEXEL_SIZE_X = 16.;\nconst float TEXEL_SIZE_Y = 512.;\nconst float ASPECT = TEXEL_SIZE_X/TEXEL_SIZE_Y;\nconst float TEXEL_OFFSET_X = (1./TEXEL_SIZE_X)*.5;\nconst float TEXEL_OFFSET_Y = (1./TEXEL_SIZE_Y)*.5;\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.1;\nconst vec3   aLightColor = vec3(0.93, 0.93, 0.89);\nconst vec3   aShadowColor = vec3(0.68, 0.69, 0.77);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nfloat trunc(float f) {\n  return f >= 0. ? floor(f) : ceil(f);\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */ /* @TODO: wow oof, this was a mistake */\n  vec2  coordTexel = vec2((trunc(vUV.x*TEXEL_SIZE_X)/TEXEL_SIZE_X)+TEXEL_OFFSET_X, ((trunc(ASPECT*vUV.y*TEXEL_SIZE_Y)/TEXEL_SIZE_Y)+TEXEL_OFFSET_Y)+((abs(mod(float(frame/3), 62.) - 31.))*(16./TEXEL_SIZE_Y)));\n  vec3  texDiffuse = texture2D(texture0, coordTexel).rgb;\n  float texSpec    = texture2D(texture0, coordTexel).a;\n\n  /* Normal */\n  vec3 normal = vNormal;\n\n  /* Specular */\n  /*float specular = specularMap(texSpec, normal);*/\n  float specular = .25;\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), texSpec);\n}\n",
};

/* Source File: goldg */
Asset.prototype.shader.gold = {
  name: "gold",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture5"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture5;      // Shadowmap Depth\nconst float TEXEL_SIZE = 16.;\nconst float TEXEL_OFFSET = (1./TEXEL_SIZE)*.5;\n\n/* General */\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.1;\nconst vec3   aLightColor = vec3(0.93, 0.93, 0.89);\nconst vec3   aShadowColor = vec3(0.68, 0.69, 0.77);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nfloat trunc(float f) {\n  return f >= 0. ? floor(f) : ceil(f);\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec2  coordTexel = vec2((trunc(vUV.x*TEXEL_SIZE)/TEXEL_SIZE)+TEXEL_OFFSET, -((trunc(vUV.y*TEXEL_SIZE)/TEXEL_SIZE)+TEXEL_OFFSET));\n  vec3  texDiffuse = texture2D(texture0, coordTexel).rgb;\n  float texSpec    = texture2D(texture0, coordTexel).a;\n\n  /* Normal */\n  vec3 normal = vNormal;\n\n  /* Specular */\n  /*float specular = specularMap(texSpec, normal);*/\n  float specular = .25;\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: fontg */
Asset.prototype.shader.font = {
  name: "font",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec2", name: "transform"},
    {type: "vec2", name: "size"},
    {type: "vec2", name: "fUV"},
    {type: "vec2", name: "fST"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec2 transform;\nuniform vec2 size;\n\nuniform vec2 fUV;\nuniform vec2 fST;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 cPos = vec4((position*vec3(size, 1.0))+vec3(transform, -0.5), 1.0);\n  vUV=vec3(fUV+(texcoord.st*fST), texcoord.z);\n  gl_Position = Pmatrix*Vmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform vec4 color;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  float a = texture2D(texture0, vUV.st).r;\n  gl_FragColor = vec4(color.rgb, a*color.a);\n}\n",
};

/* Source File: goldmaskg */
Asset.prototype.shader.goldmask = {
  name: "goldmask",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture5"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture5;      // Shadowmap Depth\nconst float TEXEL_SIZE = 16.;\nconst float TEXEL_OFFSET = (1./TEXEL_SIZE)*.5;\n\n/* General */\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.1;\nconst vec3   aLightColor = vec3(0.93, 0.93, 0.89);\nconst vec3   aShadowColor = vec3(0.68, 0.69, 0.77);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nfloat trunc(float f) {\n  return f >= 0. ? floor(f) : ceil(f);\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec2  coordTexel = vec2((trunc(vUV.x*TEXEL_SIZE)/TEXEL_SIZE)+TEXEL_OFFSET, -((trunc(vUV.y*TEXEL_SIZE)/TEXEL_SIZE)+TEXEL_OFFSET));\n  vec3  texDiffuse = texture2D(texture0, coordTexel).rgb;\n  float texMask    = texture2D(texture0, coordTexel).a;\n\n  /* Normal */\n  vec3 normal = vNormal;\n\n  /* Specular */\n  /*float specular = specularMap(texSpec, normal);*/\n  float specular = .25;\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  if(texMask < 0.5) { discard; }\n  gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: playerg */
Asset.prototype.shader.player = {
  name: "player",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "angle"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture5"},
    {type: "vec3", name: "color"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform vec3 angle;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotate(position, angle)*scale)+transform; \n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotate(normal, angle));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture5;      // Shadowmap Depth\n\n/* General */\nuniform vec3 color;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec3  texDiffuse = texture2D(texture0, vUV.st).rgb;\n  vec3  texNormal  = texture2D(texture1, vUV.st).rgb;\n  float texSpec    = texture2D(texture0, vUV.st).a;\n\n  float broit = (texDiffuse.r+texDiffuse.g+texDiffuse.b)/3.;\n  vec3 colorize = broit > .5              ?\n  (mix(color, vec3(1.), (broit-.5)*2.)) :\n  (mix(vec3(0.), color, (broit)*2.))     ;\n  vec3 texColor=colorize;\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n\n  /* Finalize */\n  gl_FragColor = vec4(texColor*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: shadowg */
Asset.prototype.shader.shadow = {
  name: "shadow",
  attributes: [
    {type: "vec3", name: "position"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\n\nuniform mat4 Pmatrix;\nuniform mat4 Lmatrix;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying float vDepth;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvoid main(void) {\n  vec4 cPos = Pmatrix*Lmatrix*Omatrix*vec4((rotateZ(position, rotation)*scale)+transform, 1.0);\n  float zBuf=cPos.z/cPos.w;\n  vDepth=0.5+zBuf*0.5;\n  gl_Position=cPos;\n}\n",
  fragment: "precision mediump float;\n\nvarying float vDepth;\n\nvoid main(void) {\n  gl_FragColor=vec4(vDepth, 0.,0.,1.);\n}\n",
};

/* Source File: postg */
Asset.prototype.shader.post = {
  name: "post",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec3[]", name: "textureProp"},
    {type: "float[]", name: "upscale"},
    {type: "sampler2D", name: "texture6"},
    {type: "sampler2D", name: "texture7"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec3 textureProp[2]; //Proportions relative to FBO texture size\nuniform float upscale[2];\n\nvarying vec2 vUVworld;\nvarying vec2 vUVui;\n\nvoid main(void) {\n  vUVworld = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[0].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVworld = vUVworld*upscale[0];\n  vUVworld.t -= textureProp[0].z;\n\n  vUVui = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[1].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVui = vUVui*upscale[1];\n  vUVui.t -= textureProp[1].z;\n\n  gl_Position = Pmatrix*Vmatrix*vec4(position,1.0);\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture6;\nuniform sampler2D texture7;\n\nvarying vec2 vUVworld;\nvarying vec2 vUVui;\n\nvoid main(void) {\n  vec4 world = texture2D(texture6, vUVworld);\n  vec4 ui = texture2D(texture7, vUVui);\n  vec4 color = ((1.0 - ui.a) * world) + (ui * ui.a);\n  gl_FragColor = vec4(color.rgb, 1.0);\n}\n",
};

/* Source File: skygoldcloudg */
Asset.prototype.shader.skygoldcloud = {
  name: "skygoldcloud",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "int", name: "frame"},
    {type: "sampler2D", name: "texture0"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nuniform int frame;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\n\nconst int mFrames = 9000;\nconst float mDist = 350.;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  float ftime = float(frame);  // No implicit casting in glsl.\n\n  float mov = mod(float(frame), float(mFrames)) * (mDist/float(mFrames));\n\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n  cPos.y += mov;\n  vPos = cPos.xyz;\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\n\nconst float fogMin = 70.;\nconst float fogMax = 125.;\n\nvoid main(void) {\n  vec4 texDir = texture2D(texture0, vUV);\n  \n  float fog = 1.-min(1., max(0., length(vPos)-fogMin)/(fogMax-fogMin));\n\n  gl_FragColor = vec4(texDir.rgb, texDir.a*fog);\n}\n",
};

/* Source File: finalspaceg */
Asset.prototype.shader.finalspace = {
  name: "finalspace",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nvarying vec2 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform int frame;\n\nvarying vec2 vUV;\n\nvoid main(void) {\n  float ftime = float(frame);  // No implicit casting in glsl.\n\n  vec4  texSky = texture2D(texture0, vUV);\n  float texSkyMask = texture2D(texture1, vUV).r;\n  float texStarMask = texture2D(texture2, ((vUV*9.55)+(vec2(-0.00077*ftime, -0.00027*ftime)))).r;\n  float texStarTwink = texture2D(texture2, ((vUV*3.33)+(vec2(0.00033*ftime, 0.00055*ftime)))).g;\n  float star = texStarMask;\n  float twink = pow(texStarTwink, 2.);\n  vec4 space = vec4(mix(texSky.rgb, vec3(star), pow(twink*star, 0.75) * 1.5), texSkyMask);\n\n  gl_FragColor = space;\n}\n",
};

/* Source File: particlespriteg */
Asset.prototype.shader.particlesprite = {
  name: "particlesprite",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "int", name: "frame"},
    {type: "int", name: "totalSprites"},
    {type: "int", name: "usedSprites"},
    {type: "vec4", name: "color"},
    {type: "vec4", name: "tone"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((vec4(rotate(position, rotation)*scale, 1.0)*Dmatrix).xyz+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nuniform int frame;\nuniform int totalSprites;\nuniform int usedSprites;\n\nuniform vec4 color;\nuniform vec4 tone;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vec2(vUV.x, (vUV.y/float(totalSprites)) + ((1./float(totalSprites)) * mod(float(frame), float(usedSprites)))));\n  vec4 colored = mix(tone, color, tex.r);\n  colored.a *= tex.a;\n  gl_FragColor = colored;\n}\n",
};

/* Source File: decalg */
Asset.prototype.shader.decal = {
  name: "decal",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture5"},
    {type: "vec4", name: "color"},
    {type: "vec3", name: "dPos"},
    {type: "vec3", name: "dNormal"},
    {type: "float", name: "dSize"},
    {type: "float", name: "dAngle"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture5;      // Shadowmap Depth Texture\n\n/* General */\nvarying vec3 vPos;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\nuniform vec4 color;\n\n/* Decal */\nuniform vec3 dPos;\nuniform vec3 dNormal;\nuniform float dSize;\nuniform float dAngle;\nconst vec3 UP = vec3(0., 0., 1.);\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = .5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Decal */\n  vec3 rPos = dPos-vPos;\n  vec3 nRot = dNormal - UP;\n  rPos = rotateZ(rPos, nRot.z);\n  rPos = rotateY(rPos, nRot.y);\n  rPos = rotateX(rPos, nRot.x);\n  rPos = rotateZ(rPos, dAngle);\n  vec3 dUVW = (rPos+vec3(.5/dSize))*dSize; /* @TODO: Optimize this by moving it to vertex where possible, also clean up the dot check for transparency also! */\n\n  /* Texture Samples */\n  vec4  texDiffuse = texture2D(texture0, dUVW.st).rgba;\n  vec3  texNormal  = texture2D(texture1, dUVW.st).rgb;\n  float texSpec    = texture2D(texture1, dUVW.st).a;\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  if(dUVW.s > 0. && dUVW.s < 1. && dUVW.t > 0. && dUVW.t < 1. && dUVW.p > 0. && dUVW.p < 1. && dot(dNormal, vNormal) > .5) {\n    gl_FragColor = vec4(texDiffuse.rgb*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), texDiffuse.a)*color;\n  }\n  else { discard; }\n}\n",
};

/* Source File: skygoldskyg */
Asset.prototype.shader.skygoldsky = {
  name: "skygoldsky",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nvarying vec2 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\n\nvarying vec2 vUV;\n\nvoid main(void) {\n  vec4 texDir = texture2D(texture0, vUV);\n  gl_FragColor = texDir;\n}\n",
};

/* Source File: effectRBg */
Asset.prototype.shader.effectRB = {
  name: "effectRB",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "int", name: "frame"},
    {type: "vec2", name: "alpha"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((rotate(position, rotation)*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\n\nuniform int frame;\nuniform vec2 alpha;\n\nvarying vec3 vUV;\n\nvec3 RGBToHSL(vec3 color)\n{\nvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\nfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\nfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\nfloat delta = fmax - fmin; //Delta RGB value\n\nhsl.z = (fmax + fmin) / 2.0; // Luminance\n\nif (delta == 0.0)	//This is a gray, no chroma...\n{\nhsl.x = 0.0;	// Hue\nhsl.y = 0.0;	// Saturation\n}\nelse //Chromatic data...\n{\nif (hsl.z < 0.5)\nhsl.y = delta / (fmax + fmin); // Saturation\nelse\nhsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\nfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\nif (color.r == fmax )\nhsl.x = deltaB - deltaG; // Hue\nelse if (color.g == fmax)\nhsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\nelse if (color.b == fmax)\nhsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\nif (hsl.x < 0.0)\nhsl.x += 1.0; // Hue\nelse if (hsl.x > 1.0)\nhsl.x -= 1.0; // Hue\n}\n\nreturn hsl;\n\n}\n\nfloat HueToRGB(float f1, float f2, float hue)\n{\nif (hue < 0.0)\nhue += 1.0;\nelse if (hue > 1.0)\nhue -= 1.0;\nfloat res;\nif ((6.0 * hue) < 1.0)\nres = f1 + (f2 - f1) * 6.0 * hue;\nelse if ((2.0 * hue) < 1.0)\nres = f2;\nelse if ((3.0 * hue) < 2.0)\nres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\nelse\nres = f1;\nreturn res;\n}\n\nvec3 HSLToRGB(vec3 hsl)\n{\nvec3 rgb;\n\nif (hsl.y == 0.0)\nrgb = vec3(hsl.z); // Luminance\nelse\n{\nfloat f2;\n\nif (hsl.z < 0.5)\nf2 = hsl.z * (1.0 + hsl.y);\nelse\nf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\nfloat f1 = 2.0 * hsl.z - f2;\n\nrgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\nrgb.g = HueToRGB(f1, f2, hsl.x);\nrgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n}\n\nreturn rgb;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n  vec3 hsly = RGBToHSL(color);\n  hsly.x = mod(hsly.x+hueAdjust, 1.);\n  return HSLToRGB(hsly);\n}\n\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st);\n  vec3 rba = texture2D(texture1, vUV.st).rgb;\n  vec3 rbb = texture2D(texture2, vUV.st).rgb;\n  vec4 colored = mix(vec4(rba, alpha.x), vec4(rbb, alpha.y), tex.r);\n  gl_FragColor = vec4(hueShift(colored.rgb, float(frame) * 0.073), colored.a * tex.a);\n}\n",
};

/* Source File: finaloutg */
Asset.prototype.shader.finalout = {
  name: "finalout",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nvarying vec2 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\n\nuniform int frame;\n\nvarying vec2 vUV;\n\nvoid main(void) {\n  float ftime = float(frame);  // No implicit casting in glsl.\n\n  float texSkyMask = texture2D(texture0, vUV).g;\n  float texStarMask = texture2D(texture1, ((vUV*1.9*vec2(8., 1.))+(vec2(-0.00077*ftime, -0.00027*ftime)))).r;\n  float texStarTwink = texture2D(texture1, ((vUV*0.77*vec2(8., 1.))+(vec2(0.00033*ftime, 0.00055*ftime)))).g;\n  float star = texStarMask;\n  float twink = pow(texStarTwink, 2.);\n  vec4 space = vec4(mix(vec3(0.), vec3(star), pow(twink*star, 0.75) * 1.5), texSkyMask);\n\n  gl_FragColor = space;\n}\n",
};

/* Source File: decal_glowg */
Asset.prototype.shader.decal_glow = {
  name: "decal_glow",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec3", name: "dPos"},
    {type: "vec3", name: "dNormal"},
    {type: "float", name: "dSize"},
    {type: "float", name: "dAngle"},
    {type: "vec4", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.0);\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nvarying vec3 vPos;\n\nuniform vec3 dPos;\nuniform vec3 dNormal;\nuniform float dSize;\nuniform float dAngle;\n\nuniform vec4 color;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  vec3 rPos = dPos-vPos;\n  rPos = rotateZ(rPos, -dAngle);\n  vec3 dUVW = (rPos+vec3(0.5/dSize))*dSize;\n\n  vec4 tex=vec4(texture2D(texture0, dUVW.st));\n\n  if(dUVW.s > 0.0 && dUVW.s < 1.0 && dUVW.t > 0.0 && dUVW.t < 1.0 && dUVW.p > 0.0 && dUVW.p < 1.0) { gl_FragColor = tex*color; }\n  else { discard; }\n}\n",
};

/* Source File: defaultg */
Asset.prototype.shader.default = {
  name: "default",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture5"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture5;      // Shadowmap Depth\n\n/* General */\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec3  texDiffuse = texture2D(texture0, vUV.st).rgb;\n  vec3  texNormal  = texture2D(texture1, vUV.st).rgb;\n  float texSpec    = texture2D(texture0, vUV.st).a;\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: skyvaporgridg */
Asset.prototype.shader.skyvaporgrid = {
  name: "skyvaporgrid",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "rotation"},
    {type: "vec3", name: "offset"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform vec3 rotation;\nuniform vec3 offset; /* Rotational offset */\nuniform float scale;\n\nvarying vec2 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Geom */\n  vec4 cPos = vec4((rotate(rotate(position, rotation), offset)+transform)*scale, 1.0);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\n\nuniform int frame;\n\nvarying vec2 vUV;\n\nconst float uvScale = 178.;\n\nvoid main(void) {\n  float ftime = float(frame);  // No implicit casting in glsl.\n\n  vec4 texDir = texture2D(texture0, (vec2(ftime*0.000073, ftime*-0.000043)+vUV)*uvScale);\n  float mask = pow(min(1., texture2D(texture1, vUV).r+.05),4.);\n\n  float plasA = texture2D(texture1, (vec2(ftime*-0.000023, ftime*0.000043)+vUV)*43.).b;\n  float plasB = texture2D(texture1, (vec2(ftime*-0.000007, ftime*-0.000013)+vUV)*37.).a;\n  float plasC = texture2D(texture1, (vec2(ftime*0.000023, ftime*-0.000018)+(vUV*vec2(-1.,1.))*31.)).b;\n\n  float plasma = pow((1.-max(0., sin((plasA+plasB+plasC)*PI))) * (1.-max(0., sin((plasA+plasB+plasC)*PI*.5))), 6.);\n\n  gl_FragColor = vec4(texDir.rgb, texDir.a*plasma*mask);\n}\n",
};

/* Source File: effect_slashRBg */
Asset.prototype.shader.effect_slashRB = {
  name: "effect_slashRB",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture3"},
    {type: "int", name: "frame"},
    {type: "int", name: "rbFrame"},
    {type: "vec2", name: "alpha"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((rotate(position, rotation)*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform sampler2D texture3;\n\nuniform int frame;\nuniform int rbFrame;\nuniform vec2 alpha;\n\nvarying vec3 vUV;\n\nvec3 RGBToHSL(vec3 color)\n{\nvec3 hsl; // init to 0 to avoid warnings ? (and reverse if + remove first part)\n\nfloat fmin = min(min(color.r, color.g), color.b); //Min. value of RGB\nfloat fmax = max(max(color.r, color.g), color.b); //Max. value of RGB\nfloat delta = fmax - fmin; //Delta RGB value\n\nhsl.z = (fmax + fmin) / 2.0; // Luminance\n\nif (delta == 0.0)	//This is a gray, no chroma...\n{\nhsl.x = 0.0;	// Hue\nhsl.y = 0.0;	// Saturation\n}\nelse //Chromatic data...\n{\nif (hsl.z < 0.5)\nhsl.y = delta / (fmax + fmin); // Saturation\nelse\nhsl.y = delta / (2.0 - fmax - fmin); // Saturation\n\nfloat deltaR = (((fmax - color.r) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaG = (((fmax - color.g) / 6.0) + (delta / 2.0)) / delta;\nfloat deltaB = (((fmax - color.b) / 6.0) + (delta / 2.0)) / delta;\n\nif (color.r == fmax )\nhsl.x = deltaB - deltaG; // Hue\nelse if (color.g == fmax)\nhsl.x = (1.0 / 3.0) + deltaR - deltaB; // Hue\nelse if (color.b == fmax)\nhsl.x = (2.0 / 3.0) + deltaG - deltaR; // Hue\n\nif (hsl.x < 0.0)\nhsl.x += 1.0; // Hue\nelse if (hsl.x > 1.0)\nhsl.x -= 1.0; // Hue\n}\n\nreturn hsl;\n\n}\n\nfloat HueToRGB(float f1, float f2, float hue)\n{\nif (hue < 0.0)\nhue += 1.0;\nelse if (hue > 1.0)\nhue -= 1.0;\nfloat res;\nif ((6.0 * hue) < 1.0)\nres = f1 + (f2 - f1) * 6.0 * hue;\nelse if ((2.0 * hue) < 1.0)\nres = f2;\nelse if ((3.0 * hue) < 2.0)\nres = f1 + (f2 - f1) * ((2.0 / 3.0) - hue) * 6.0;\nelse\nres = f1;\nreturn res;\n}\n\nvec3 HSLToRGB(vec3 hsl)\n{\nvec3 rgb;\n\nif (hsl.y == 0.0)\nrgb = vec3(hsl.z); // Luminance\nelse\n{\nfloat f2;\n\nif (hsl.z < 0.5)\nf2 = hsl.z * (1.0 + hsl.y);\nelse\nf2 = (hsl.z + hsl.y) - (hsl.y * hsl.z);\n\nfloat f1 = 2.0 * hsl.z - f2;\n\nrgb.r = HueToRGB(f1, f2, hsl.x + (1.0/3.0));\nrgb.g = HueToRGB(f1, f2, hsl.x);\nrgb.b= HueToRGB(f1, f2, hsl.x - (1.0/3.0));\n}\n\nreturn rgb;\n}\n\nvec3 hueShift( vec3 color, float hueAdjust ){\n  vec3 hsly = RGBToHSL(color);\n  hsly.x = mod(hsly.x+hueAdjust, 1.);\n  return HSLToRGB(hsly);\n}\n\n\nvoid main(void) {\n  vec2 uv = (vUV.st*vec2(0.5,1.0))+vec2(1.0, 0.0)-vec2(float(frame)*0.1725, 1.0);\n  if(uv.x > 1.0 || uv.x < 0.0) { discard; }\n  vec4 gradTex = texture2D(texture1, uv);\n  vec4 maskTex = texture2D(texture0, vUV.st);\n  vec3 rba = texture2D(texture2, vUV.st).rgb;\n  vec3 rbb = texture2D(texture3, vUV.st).rgb;\n\n  vec4 colored = mix(vec4(rba, alpha.x), vec4(rbb, alpha.y), maskTex.r);\n  gl_FragColor = vec4(hueShift(colored.rgb, float(rbFrame) * 0.073), colored.a * maskTex.a * gradTex.a);\n}\n",
};

/* Source File: post_msaa_bloomg */
Asset.prototype.shader.post_msaa_bloom = {
  name: "post_msaa_bloom",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3[]", name: "textureProp"},
    {type: "vec2", name: "resolution"},
    {type: "float[]", name: "upscale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture6"},
    {type: "sampler2D", name: "texture7"},
    {type: "sampler2D", name: "texture8"},
    {type: "sampler2D", name: "texture9"},
    {type: "sampler2D", name: "texture10"},
    {type: "sampler2D", name: "texture11"},
    {type: "float", name: "bloomTextureAspect"},
    {type: "float", name: "bloomTextureScale"},
    {type: "vec2", name: "bloomTexel"},
    {type: "float", name: "bloomScale"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec3 transform;\n\nuniform vec3 textureProp[4]; //Proportions relative to FBO texture size\nuniform vec2 resolution;\nuniform float upscale[4];\n\nvarying vec2 vUVworld[3];\nvarying vec2 vUVui;\nvarying vec2 vUVsky;\nvarying vec2 vUVbloom;\n\nvoid main(void) {\n  vUVworld[0] = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[0].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVworld[0] = vUVworld[0]*upscale[0];\n  vUVworld[0].t -= textureProp[0].z;\n\n  vec2 pixOffset = 0.5/(resolution/upscale[0]);\n  vUVworld[1] = vUVworld[0] + vec2(pixOffset.x, 0.0);\n  vUVworld[2] = vUVworld[0] + vec2(0.0, pixOffset.y);\n\n  vUVui = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[1].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVui = vUVui*upscale[1];\n  vUVui.t -= textureProp[1].z;\n  \n  vUVsky = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[2].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVsky = vUVsky*upscale[2];\n  vUVsky.t -= textureProp[2].z;\n\n  vUVbloom = vec2(texcoord.s, (-1.0*texcoord.t))*textureProp[3].st; /* @FIXME Unknown why we need to render inverse y coords */\n  vUVbloom = vUVbloom*upscale[3];\n  vUVbloom.t -= textureProp[3].z;\n\n  gl_Position = Pmatrix*Vmatrix*vec4(position,1.0);\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture6;   // Game World\nuniform sampler2D texture7;   // UI\nuniform sampler2D texture8;   // Sky\nuniform sampler2D texture9;   // Game World Bloom\nuniform sampler2D texture10;  // Game World Depth\nuniform sampler2D texture11;  // Game World Bloom Depth\n\nuniform float bloomTextureAspect; // To adjust the vertical/horizontal radius of bloom blurring\nuniform float bloomTextureScale;  // To adjust for the amount texture space actually used by the fbo\n\nvarying vec2 vUVworld[3];\nvarying vec2 vUVui;\nvarying vec2 vUVsky;\nvarying vec2 vUVbloom;\n\nuniform vec2 bloomTexel;\nuniform float bloomScale;\nconst int bloomSamples = 6;\nconst float bloomDepthBias = .00025;\n\nvec4 bloomBlur() {\n  vec4 sum = vec4(0.);\n  vec2 gaussScale = bloomTexel*bloomScale;\n  for(int i=-bloomSamples;i<=bloomSamples;i++) {\n    for(int j=-bloomSamples;j<=bloomSamples;j++) {\n      vec2 vUVoffset = gaussScale*vec2(float(i),float(j));\n      vec4 worldDepthSamp = texture2D(texture10, vUVworld[0] + vUVoffset);\n      vec4 bloomDepthSamp = texture2D(texture11, vUVbloom + vUVoffset);\n      vec4 bloomSamp = texture2D(texture9, vUVbloom + vUVoffset);\n      sum += worldDepthSamp.r+bloomDepthBias>=bloomDepthSamp.r?bloomSamp:vec4(0.,0.,0.,0.);\n    }\n  }\n  return sum/pow(float(bloomSamples)*2., 1.85);\n}\n\nvoid main(void) {\n  vec4 worldSampA = texture2D(texture6, vUVworld[0]);\n  vec4 worldSampB = texture2D(texture6, vUVworld[1]);\n  vec4 worldSampC = texture2D(texture6, vUVworld[2]);\n\n  vec4 world = (worldSampA+worldSampB+worldSampC)/3.; /* @TODO: Great Value MSAA / Should sample pixels in area based on fbo//actual resolution */\n  vec4 ui = texture2D(texture7, vUVui);\n  vec4 sky = texture2D(texture8, vUVsky);\n  vec4 bloom = bloomBlur();\n\n  // Sky + World\n  vec3 color = vec3((world.a*world.rgb)+((1.-world.a)*sky.rgb));\n\n  // + Bloom\n  color = clamp(color + (bloom.rgb*bloom.a), vec3(0.), vec3(1.));\n\n  // + UI\n  color = ((1. - ui.a) * color) + (ui.rgb * ui.a);\n  \n  gl_FragColor = vec4(color, 1.);\n}\n",
};

/* Source File: cubeg */
Asset.prototype.shader.cube = {
  name: "cube",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "int", name: "frame"},
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "int", name: "frame"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
  ],
  vertex: "precision mediump float;\nprecision mediump int;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform int frame;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 rotate(vec3 a, vec3 b) {\n  vec3 c = rotateX(a, b.x);\n  c = rotateY(c, b.y);\n  c = rotateZ(c, b.z);\n  return c;\n}\n\n\nvoid main(void) {\n  /* Position */\n  float ff = float(frame);\n\n  vec3 fullRot = vec3(ff*.00023, ff*.00247, ff*.00353 + rotation);\n  float fullScale = scale * (1. + (.05*sin(ff*.00438)));\n\n  vPos = (rotate(position, fullRot)*fullScale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\nprecision mediump int;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Mask\nuniform sampler2D texture1;      // Multi-Dif\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\n\nvoid main(void) {\n  /* Texture Samples */\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  float texMask    = mix(texture2D(texture0, vUV).r, texture2D(texture0, vUV).b, sin(ff*.055));\n  float texGrad    = mix(texture2D(texture0, vUV).g, texture2D(texture0, vUV).a, sin(ff*.055));\n  float multiR     = texture2D(texture1, (1.375*vUV)+vec2(ff*0.00113, ff*0.00097)).r;\n  float multiG     = texture2D(texture1, (1.4*vUV)+vec2(-ff*0.00013, ff*0.00267)).g;\n  float multiB     = texture2D(texture1, (1.45*vUV)+vec2(ff*0.00211, -ff*0.00143)).b;\n  float multiA     = texture2D(texture1, (1.5*vUV)+(vec2(-ff*0.00171, -ff*0.00123))*-1.).r; /* Yeah I know... remind me to add an A channel to it */\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n\n  vec4 colorA = vec4(1.0, 1.0, 1.0, 1.0);\n  vec4 colorB = vec4(vec3(min(1., max(0.0001, plasGlow))), 1.);\n  vec4 colorC = vec4(0.0, 0.0, 0.0, 1.0);\n\n  /* Finalize */\n  gl_FragColor = mix(mix(colorC, colorB, texGrad), colorA, texMask);\n}\n",
};

/* Source File: final_spaceg */
Asset.prototype.shader.final_space = {
  name: "final_space",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec2", name: "size"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture3"},
    {type: "sampler2D", name: "texture4"},
    {type: "int", name: "time"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\n\nuniform vec3 transform;\nuniform vec2 size;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 cPos = vec4((position*vec3(size,1.0))+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\nuniform sampler2D texture1;\nuniform sampler2D texture2;\nuniform sampler2D texture3;\nuniform sampler2D texture4;\n\nuniform int time;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  float ftime = float(time);  // No implicit casting in glsl. \n\n  /* Background */\n  vec3  samp0 = texture2D(texture0, vUV.st).rgb;\n  float samp1 = texture2D(texture2, (vUV.st*3.0+(vec2(0.00137*ftime, 0.00057*ftime)))).a;  \n  float samp2 = texture2D(texture3, (vUV.st*5.5+(vec2(-0.00023*ftime, -0.00015*ftime)))).r;\n  \n  float star = min(pow(samp2*2., 2.),1.)*0.5;\n  vec4 space = vec4(mix(samp0, vec3(star), samp1*star), 1.0);\n\n  /* Foreground */\n  float samp3a = texture2D(texture1, ((vUV.st*vec2(0.5,1.0))+vec2(-0.00047*ftime,0.0))).r;\n  float samp3b = texture2D(texture1, ((vUV.st*vec2(0.5,1.0))+vec2(-0.00083*ftime,0.0))).g;\n  float samp3c = texture2D(texture1, ((vUV.st*vec2(0.5,1.0))+vec2(-0.00016*ftime,0.0))).b;\n\n  vec3  samp4 = texture2D(texture2, (vUV.st+vec2(0.0023*ftime, -0.0037*ftime))).rgb;\n  float samp5 = texture2D(texture4, (vUV.st*1.5+(vec2(0.0043*ftime, -0.0025*ftime)))).r;\n  float samp6 = texture2D(texture4, (vUV.st*1.3+(vec2(-0.0023*ftime, 0.0033*ftime)))).g;\n  float samp7 = texture2D(texture4, (vUV.st*1.1+(vec2(-0.0026*ftime, -0.0015*ftime)))).b;\n  float samp8 = texture2D(texture4, (vUV.st*1.4+(vec2(0.0033*ftime, 0.0042*ftime)))).r;\n\n  vec4 lines = vec4(samp4, min(samp3a+samp3b+samp3c, 1.0)*((samp5/samp6)*(samp7/samp8)));\n\n  gl_FragColor = vec4(mix(space.rgb, lines.rgb, lines.a), 1.0);\n}\n",
};

/* Source File: particleg */
Asset.prototype.shader.particle = {
  name: "particle",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((vec4(rotate(position, rotation)*scale, 1.0)*Dmatrix).xyz+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nuniform vec4 color;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st)*color;\n  gl_FragColor = tex;\n}\n",
};

/* Source File: gold2xg */
Asset.prototype.shader.gold2x = {
  name: "gold2x",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture5"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture5;      // Shadowmap Depth\nconst float TEXEL_SIZE_X = 16.;\nconst float TEXEL_SIZE_Y = 32.;\nconst float TEXEL_OFFSET_X = (1./TEXEL_SIZE_X)*.5;\nconst float TEXEL_OFFSET_Y = (1./TEXEL_SIZE_Y)*.5;\n\n/* General */\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.1;\nconst vec3   aLightColor = vec3(0.93, 0.93, 0.89);\nconst vec3   aShadowColor = vec3(0.68, 0.69, 0.77);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nfloat trunc(float f) {\n  return f >= 0. ? floor(f) : ceil(f);\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec2  coordTexel = vec2((trunc(vUV.x*TEXEL_SIZE_X)/TEXEL_SIZE_X)+TEXEL_OFFSET_X, -((trunc(vUV.y*TEXEL_SIZE_Y)/TEXEL_SIZE_Y)+TEXEL_OFFSET_Y));\n  vec3  texDiffuse = texture2D(texture0, coordTexel).rgb;\n  float texSpec    = texture2D(texture0, coordTexel).a;\n\n  /* Normal */\n  vec3 normal = vNormal;\n\n  /* Specular */\n  /*float specular = specularMap(texSpec, normal);*/\n  float specular = .25;\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: tin_gridg */
Asset.prototype.shader.tin_grid = {
  name: "tin_grid",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture3"},
    {type: "sampler2D", name: "texture4"},
    {type: "sampler2D", name: "texture5"},
    {type: "int", name: "frame"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n  vec3 up = vec3(0.,0.,1.);\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  wUV = rotateX(rotateZ(rotateY(vPos, axAng.x), axAng.y), -axAng.z).st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Mask\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture2;      // Edge\nuniform sampler2D texture3;      // Multi\nuniform sampler2D texture4;      // Special + Specular\nuniform sampler2D texture5;      // Shadowmap Depth\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\nvec3 plasma(sampler2D texColor, sampler2D texDiff, vec2 uv, float scale) {\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  float multiR     = texture2D(texDiff, (uv+vec2(ff*0.00113, ff*0.00097))*scale).r;\n  float multiG     = texture2D(texDiff, (uv+vec2(-ff*0.00013, ff*0.00267))*scale).g;\n  float multiB     = texture2D(texDiff, (uv+vec2(ff*0.00211, -ff*0.00143))*scale).b;\n  float multiA     = texture2D(texDiff, (uv+vec2(-ff*0.00171, -ff*0.00123)*scale)*-1.).r; /* @TODO: Yeah I know... remind me to add an A channel to it */\n  vec3  texGlowA   = texture2D(texColor, gt).rgb;\n  vec3  texGlowB   = texture2D(texColor, gt+vec2(.5, 0.)).rgb;\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n  \n  return mix(texGlowA, (texGlowB+vec3(.15))*((sin(ff*.0127)*.25)+1.5), min(max(0.0001, plasGlow), 1.));\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  vec3  texDiffuse = texture2D(texture0, wUV.st*6.).rgb;\n  vec3  texNormal  = texture2D(texture1, wUV.st*6.).rgb;\n  float texMask    = texture2D(texture0, wUV.st*6.).a;\n  float texSpec    = texture2D(texture4, wUV.st*6.).y;\n  vec3 glow = plasma(texture2, texture3, wUV, 2.);\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n  /* Finalize */\n  if(vUV.s >= 0.0) {\n    if(texMask < 0.5) { discard; }\n    gl_FragColor = vec4(texDiffuse*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n  }\n  else {\n    gl_FragColor = vec4(glow, 1.);\n  }\n}\n",
};

/* Source File: playerdeltag */
Asset.prototype.shader.playerdelta = {
  name: "playerdelta",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "PmatrixLight"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture5"},
    {type: "samplerCube", name: "cube"},
    {type: "vec3", name: "color"},
    {type: "vec3", name: "aLightDirection"},
    {type: "vec2", name: "cameraCenter"},
    {type: "vec3", name: "eyeCenter"},
    {type: "vec3", name: "eyeDirection"},
    {type: "int", name: "shadowTextureSize"},
    {type: "int", name: "pLightLength"},
    {type: "vec3[]", name: "pLightPos"},
    {type: "vec3[]", name: "pLightColor"},
    {type: "float[]", name: "pLightRadius"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform mat4 Lmatrix;\nuniform mat4 PmatrixLight;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Shadow & Light */\n  vec4 lightPos = Lmatrix*Omatrix*cPos;\n  lightPos=PmatrixLight*lightPos;\n  vec3 lightPosDNC=lightPos.xyz/lightPos.w;\n  vLightPos=vec3(.5)+lightPosDNC*.5;\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Diffuse + Specular\nuniform sampler2D texture1;      // Normal\nuniform sampler2D texture5;      // Shadowmap Depth\nuniform samplerCube cube;\n\n/* General */\nuniform vec3 color;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec3 vNormal;\nvarying vec3 vLightPos;\n\n/* Ambient Light & Shadow Settings */\nconst float  specularity = 0.5;\nconst vec3   aLightColor = vec3(0.98, 0.98, 0.98);\nconst vec3   aShadowColor = vec3(0.35, 0.35, 0.35);\nuniform vec3 aLightDirection;\n\nuniform vec2  cameraCenter;\nuniform vec3  eyeCenter;\nuniform vec3  eyeDirection;\nuniform int   shadowTextureSize;\n\n/* Dynamic Light Settings */\nuniform int   pLightLength;\nuniform vec3  pLightPos[64];\nuniform vec3  pLightColor[64];\nuniform float pLightRadius[64];\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\nconst   float shadowMaxRadius = 12.;\nconst   float shadowMaxRadiusBlend = 2.;\nfloat shadowMap() {\n  float shadowDist = length(cameraCenter - vPos.xy); // Distance to max shadow radus\n  float shadowValue;  // Shadow value for this pixel < 0 - 1 >\n  if(shadowDist >= shadowMaxRadius) { return 0.; }\n  float blend = 1.-min(1., max(0., (shadowDist+shadowMaxRadiusBlend)-shadowMaxRadius)/shadowMaxRadiusBlend);\n  float sum = 0.;\n  float siz = float(shadowTextureSize);\n  for(float x=-2.5;x<=2.5;x+=1.25) {   // 4x4 (16) PCF shadow filtering\n    for(float y=-2.5;y<=2.5;y+=1.25) {\n      sum += vLightPos.z-texture2D(texture5, vLightPos.xy+vec2(x/siz,y/siz)).r>0.005?0.:1.;\n    }\n  }\n  return (sum/16.)*blend;\n}\n\nconst vec3 up = vec3(0.,0.,1.);\nvec3 normalMap(vec3 texNormal) {\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  vec3 cenTexNorm = (texNormal - vec3(.5))*2.;\n  return rotateX(rotateZ(rotateY(cenTexNorm, axAng.x), axAng.y), -axAng.z);\n}\n\nfloat specularMap(float texSpec, vec3 normal) {\n  vec3 specDir  = normalize(vPos-(-eyeCenter));\n  vec3 specRef  = reflect(-aLightDirection, normal);\n  float specCenter = pow(max(0., dot(specDir, -eyeDirection)), 12.);\n  float specStr    = pow(max(0., dot(specRef, -eyeDirection)), 4.);\n  return texSpec*specStr*specCenter;\n}\n\nconst int pMaxLights = 32;    // Stop drawing lights after this #\nvec3 dynamicLight() {\n  vec3 pLight = vec3(0.);\n  for(int i=0;i<pMaxLights;i++) {\n    if(!(i<pLightLength)) { break; }\n\n    vec3 mag = (pLightPos[i]) - vPos;\n    float dist = sqrt((mag.x*mag.x) + (mag.y*mag.y) + (mag.z*mag.z));\n\n    if(dist < pLightRadius[i]) {\n      pLight += pLightColor[i]*(1.-(dist/pLightRadius[i]));\n    }\n  }\n  return pLight;\n}\n\n\nvoid main(void) {\n\n  /* Shadow Map Calculations */\n  float shadowValue = shadowMap();\n\n  /* Texture Samples */\n  vec3  texDiffuse = texture2D(texture0, vUV.st).rgb;\n  vec3  texNormal  = texture2D(texture1, vUV.st).rgb;\n  float texSpec    = texture2D(texture0, vUV.st).a;\n\n  float broit = (texDiffuse.r+texDiffuse.g+texDiffuse.b)/3.;\n  vec3 colorize = broit > .5              ?\n  (mix(color, vec3(1.), (broit-.5)*2.)) :\n  (mix(vec3(0.), color, (broit)*2.));\n  vec3 texColor=colorize;\n\n  /* Normal */\n  vec3 normal = normalMap(texNormal);\n\n  /* Specular */\n  float specular = specularMap(texSpec, normal);\n\n  /* Cubemap */\n  vec3 cRef  = reflect(normalize(vPos-(-eyeCenter)), normal);\n  vec3 texCube = textureCube(cube, cRef).rgb;\n  \n  /* Mix Color */\n  vec3 qBroit = vec3((texCube.r + texCube.g + texCube.b)/3.);\n  vec3 recolor = broit > 0.725 ? texColor : mix(texColor*qBroit, vec3(1.), 0.15);\n\n  /* Light & Shadow Values */\n  vec3 aLight = mix(aShadowColor, aLightColor, shadowValue*max(0., dot(normal, -aLightDirection)));\n  vec3 pLight = dynamicLight();\n\n\n  /* Finalize */\n  gl_FragColor = vec4(recolor*((aLight+pLight)+(shadowValue*specular*specularity*aLightColor)), 1.);\n}\n",
};

/* Source File: particle2toneg */
Asset.prototype.shader.particle2tone = {
  name: "particle2tone",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
    {type: "vec4", name: "tone"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((vec4(rotate(position, rotation)*scale, 1.0)*Dmatrix).xyz+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nuniform vec4 color;\nuniform vec4 tone;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st);\n  vec4 colored = mix(tone, color, tex.r);\n  colored.a *= tex.a;\n  gl_FragColor = colored;\n}\n",
};

/* Source File: mapbloom_negxg */
Asset.prototype.shader.mapbloom_negx = {
  name: "mapbloom_negx",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture3"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\nvarying vec3 vNormal;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV=texcoord.st;\n  vec3 up = vec3(0.,0.,1.);\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  wUV = rotateX(rotateZ(rotateY(vPos, axAng.x), axAng.y), -axAng.z).st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture2;      // Edge\nuniform sampler2D texture3;      // Multi\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 vUV;\nvarying vec2 wUV;\n\nvec3 plasma(sampler2D texColor, sampler2D texDiff, vec2 uv, float scale) {\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  float multiR     = texture2D(texDiff, (uv+vec2(ff*0.00113, ff*0.00097))*scale).r;\n  float multiG     = texture2D(texDiff, (uv+vec2(-ff*0.00013, ff*0.00267))*scale).g;\n  float multiB     = texture2D(texDiff, (uv+vec2(ff*0.00211, -ff*0.00143))*scale).b;\n  float multiA     = texture2D(texDiff, (uv+vec2(-ff*0.00171, -ff*0.00123)*scale)*-1.).r; /* @TODO: Yeah I know... remind me to add an A channel to it */\n  vec3  texGlowA   = texture2D(texColor, gt).rgb;\n  vec3  texGlowB   = texture2D(texColor, gt+vec2(.5, 0.)).rgb;\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n  \n  return mix(texGlowA, (texGlowB+vec3(.15))*((sin(ff*.0127)*.25)+1.5), min(max(0.0001, plasGlow), 1.));\n}\n\n\nvoid main(void) {\n  /* Texture Samples */\n  vec3 glow = plasma(texture2, texture3, wUV, 2.);\n\n  /* Finalize */\n  if(vUV.s >= 0.) { discard; }\n  else { gl_FragColor = vec4(glow, 1.); }\n}\n",
};

/* Source File: ironplasmag */
Asset.prototype.shader.ironplasma = {
  name: "ironplasma",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
    {type: "vec3", name: "normal"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
    {type: "sampler2D", name: "texture1"},
    {type: "sampler2D", name: "texture2"},
    {type: "sampler2D", name: "texture5"},
    {type: "int", name: "frame"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\nattribute vec3 normal;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying vec3 vPos;\nvarying vec2 wUV;\nvarying vec2 vUV;\nvarying vec3 vNormal;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\n\nvoid main(void) {\n  /* Position */\n  vPos = (rotateZ(position, rotation)*scale)+transform;\n  vec4 cPos = vec4(vPos, 1.);\n\n  /* Geom Normal */\n  vNormal=normalize(rotateZ(normal, rotation));\n\n  /* Texture Coordinates */\n  vUV = texcoord.st;\n  vec3 up = vec3(0.,0.,1.);\n  vec3 axis = cross(up, vNormal);\n  float angle = acos(dot(up, vNormal));\n  vec3 axAng = axisAngle(axis, angle);\n  wUV = rotateX(rotateZ(rotateY(vPos, axAng.x), axAng.y), -axAng.z).st;\n\n  /* Final */\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\n/* Texture Samples */\nuniform sampler2D texture0;      // Edge\nuniform sampler2D texture1;      // Multi\nuniform sampler2D texture2;      // Mask\nuniform sampler2D texture5;      // Shadowmap Depth Texture\n\n/* General */\nuniform int  frame;\nvarying vec3 vPos;\nvarying vec2 wUV;\nvarying vec2 vUV;\nvarying vec3 vNormal;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvec3 axisAngle(vec3 a, float b) {\n  float x, y, z;\n\n  float s=sin(b);\n  float c=cos(b);\n  float t=1.-c;\n  if ((a.x*a.y*t + a.z*s) > 0.998) { // north pole singularity detected\n      x = 2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = PI/2.;\n      z = 0.;\n  }\n  else if ((a.x*a.y*t + a.z*s) < -0.998) { // south pole singularity detected\n      x = -2.*atan(a.x*sin(b/2.),cos(b/2.));\n      y = -PI/2.;\n      z = 0.;\n  }\n  else {\n    x = atan(a.y * s - a.x * a.z * t , 1. - (a.y*a.y+ a.z*a.z ) * t);\n    y = asin(a.x * a.y * t + a.z * s) ;\n    z = atan(a.x * s - a.y * a.z * t , 1. - (a.x*a.x + a.z*a.z) * t);\n  }\n  return vec3(x,y,z);\n}\n\n\nvoid main(void) {\n\n  /* Texture Samples */\n  float ff = float(frame);\n  vec2  gt = vec2(ff*0.00147, .5);\n  vec3 mask       = texture2D(texture2, -vUV).rgb;\n  float multiR     = texture2D(texture1, (wUV+vec2(ff*0.00113, ff*0.00097))*1.).r;\n  float multiG     = texture2D(texture1, (wUV+vec2(-ff*0.00013, ff*0.00267))*1.).g;\n  float multiB     = texture2D(texture1, (wUV+vec2(ff*0.00211, -ff*0.00143))*1.).b;\n  float multiA     = texture2D(texture1, (wUV+vec2(-ff*0.00171, -ff*0.00123)*1.)*-1.).r; /* @TODO: Yeah I know... remind me to add an A channel to it */\n  vec4  texGlowA   = vec4(texture2D(texture0, gt).rgb, .1);\n  vec4  texGlowB   = vec4(texture2D(texture0, gt+vec2(.5, 0.)).rgb, 1.);\n  vec4  texGlowC   = vec4(texture2D(texture0, gt).rgb, .2);\n\n  float sum = multiR + multiG + multiB + multiA;\n  float plasGlow = pow(1.-(sin(sum*PI)*(1.-sin(sum*(PI/2.))*1.-sin(sum*(PI/3.)))), 16.);\n  \n  float blend = min(max(0.0001, plasGlow), 1.);\n  vec4 glow = mix(mix(texGlowA, texGlowB, min(max(0.0001, blend*16.), 1.)), vec4((texGlowC.rgb+vec3(.15))*((sin(ff*.0127)*.25)+1.5), texGlowC.a), blend);\n  glow.a *= mask.r;\n\n  /* Finalize */\n  gl_FragColor = vec4(glow.rgb, min(1., glow.a+mask.g));\n}\n",
};

/* Source File: particlemodelg */
Asset.prototype.shader.particlemodel = {
  name: "particlemodel",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "mat4", name: "Dmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "vec3", name: "angle"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
    {type: "vec4", name: "tone"},
  ],
  vertex: "precision mediump float;\n#define PI 3.1415926535897932384626433832795\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\nuniform mat4 Dmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform vec3 angle;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotateX(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float y = (a.y * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.y * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(a.x, y, z);\n}\n\nvec3 rotateY(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.z * sinDegrees);\n    float z = (a.x * -sinDegrees) + (a.z * cosDegrees);\n\n    return vec3(x, a.y, z);\n}\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\n\nvoid main(void) {\n  vec3 hacky = rotateX(rotateZ(rotateY(position, angle.x), angle.y), -angle.z);\n\n  vec4 cPos = vec4((hacky*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nuniform vec4 color;\nuniform vec4 tone;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st);\n  vec4 colored = mix(tone, color, tex.r);\n  colored.a *= tex.a;\n  gl_FragColor = colored;\n}\n",
};

/* Source File: debugg */
Asset.prototype.shader.debug = {
  name: "debug",
  attributes: [
    {type: "vec3", name: "position"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "vec3", name: "color"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\n\nvoid main(void) {\n  vec4 cPos = vec4(position+transform, 1.0);\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform vec3 color;\n\nvoid main(void) {\n  gl_FragColor = vec4(color, 1.0);\n}\n",
};

/* Source File: shadowmaskg */
Asset.prototype.shader.shadowmask = {
  name: "shadowmask",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Lmatrix"},
    {type: "mat4", name: "Omatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "rotation"},
    {type: "float", name: "scale"},
    {type: "sampler2D", name: "texture0"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Lmatrix;\nuniform mat4 Omatrix;\n\nuniform vec3 transform;\nuniform float rotation;\nuniform float scale;\n\nvarying float vDepth;\nvarying vec2 vUV;\n\nvec3 rotateZ(vec3 a, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (a.x * cosDegrees) + (a.y * sinDegrees);\n    float y = (a.x * -sinDegrees) + (a.y * cosDegrees);\n\n    return vec3(x, y, a.z);\n}\n\nvoid main(void) {\n  vec4 cPos = Pmatrix*Lmatrix*Omatrix*vec4((rotateZ(position, rotation)*scale)+transform, 1.0);\n  float zBuf=cPos.z/cPos.w;\n  vDepth=0.5+zBuf*0.5;\n  vUV=texcoord.st;\n  gl_Position=cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;      // Alpha of this texture is the mask\n\nvarying float vDepth;\nvarying vec2 vUV;               // Uses mesh UV's not world UV's.\n\nvoid main(void) {\n  float texMask = texture2D(texture0, vec2(vUV.x, -vUV.y)).a;\n  if(texMask < 0.5) { discard; }\n  gl_FragColor=vec4(vDepth, 0.,0.,1.);\n\n}\n",
};

/* Source File: effect2toneg */
Asset.prototype.shader.effect2tone = {
  name: "effect2tone",
  attributes: [
    {type: "vec3", name: "position"},
    {type: "vec3", name: "texcoord"},
  ],
  uniforms: [
    {type: "mat4", name: "Pmatrix"},
    {type: "mat4", name: "Vmatrix"},
    {type: "mat4", name: "Mmatrix"},
    {type: "vec3", name: "transform"},
    {type: "float", name: "scale"},
    {type: "float", name: "rotation"},
    {type: "sampler2D", name: "texture0"},
    {type: "vec4", name: "color"},
    {type: "vec4", name: "tone"},
  ],
  vertex: "precision mediump float;\n\nattribute vec3 position;\nattribute vec3 texcoord;\n\nuniform mat4 Pmatrix;\nuniform mat4 Vmatrix;\nuniform mat4 Mmatrix;\n\nuniform vec3 transform;\nuniform float scale;\nuniform float rotation;\n\nvarying vec3 vPos;\nvarying vec3 vUV;\n\nvec3 rotate(vec3 v, float r) {\n    float cosDegrees = cos(r);\n    float sinDegrees = sin(r);\n\n    float x = (v.x * cosDegrees) + (v.y * sinDegrees);\n    float y = (v.x * -sinDegrees) + (v.y * cosDegrees);\n\n    return vec3(x, y, v.z);\n}\n\nvoid main(void) {\n  vec4 cPos = vec4((rotate(position, rotation)*scale)+transform, 1.0);\n  vUV=texcoord;\n  gl_Position = Pmatrix*Vmatrix*Mmatrix*cPos;\n}\n",
  fragment: "precision mediump float;\n\nuniform sampler2D texture0;\n\nuniform vec4 color;\nuniform vec4 tone;\n\nvarying vec3 vUV;\n\nvoid main(void) {\n  vec4 tex = texture2D(texture0, vUV.st);\n  vec4 colored = mix(tone, color, tex.r);\n  colored.a *= tex.a;\n  gl_FragColor = colored;\n}\n",
};

